\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{adjustbox}
\usepackage{multirow}

% Code listing style
\lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny,
    tabsize=4
}

\title{\textbf{ECE 401: Advanced Computer Architecture\\
RISC-V Pipelined Processor Design and Optimization\\
Project Report}}

\author{Akash Kolukonda, Zihao Xin, Hengde Dai}
\date{December 7, 2025}

\begin{document}

\maketitle

% =============================================================================
% ABSTRACT
% =============================================================================
\begin{abstract}
This report presents the design, optimization, and evaluation of a 5-stage pipelined RISC-V processor supporting the RV32I instruction set. Starting from the MERL-DSU open-source baseline, we identified critical limitations including missing load-use hazard detection and inadequate branch flushing mechanisms. Our optimizations focused on three key areas: (1) implementing comprehensive data forwarding for both Execute and Decode stages, (2) adding load-use hazard detection with pipeline stalling, and (3) fixing control hazard handling with proper branch flushing. The optimized processor correctly executes test programs involving data dependencies, load-use sequences, and conditional branches. Simulation results using Icarus Verilog and GTKWave demonstrate functional correctness across all hazard scenarios, with the processor achieving improved CPI through reduced pipeline stalls.
\end{abstract}

% =============================================================================
% Part 1: Baseline Processor Description
% =============================================================================
\section{Part 1: Baseline Processor Description}

This project implements a pipelined RISC-V processor supporting the RV32I instruction set. Our work is based on the MERL-DSU RISC-V Pipeline Core open-source repository, which provides a functional 5-stage pipelined processor implemented in Verilog.

\subsection{Pipeline Structure}

Our baseline processor implements a classical 5-stage pipeline: Instruction Fetch (IF), Instruction Decode (ID), Execute (EX), Memory (MEM), and Writeback (WB). Figure~\ref{fig:architecture} shows the complete processor architecture.

\begin{figure}[h]
\centering
\includegraphics[width=0.95\textwidth]{top.png}
\caption{5-Stage Pipelined RISC-V Processor Architecture}
\label{fig:architecture}
\end{figure}

\subsubsection{Fetch Stage}
The Fetch stage manages the program counter and retrieves instructions from instruction memory. Key components include:
\begin{itemize}[noitemsep]
    \item PC register with synchronous update
    \item PC+4 adder for sequential addressing
    \item Multiplexer selecting between PC+4 and branch target (PCTargetE)
    \item Pipeline register propagating InstrD, PCD, and PCPlus4D to Decode stage
\end{itemize}

\subsubsection{Decode Stage}
The Decode stage decodes instructions and reads operands from the register file. Key components include:
\begin{itemize}[noitemsep]
    \item \textbf{Control Unit:} Hierarchical design with Main Decoder, Branch Decoder, and ALU Decoder
    \item \textbf{Register File:} 32 registers with dual-port read and single-port write
    \item \textbf{Sign Extend:} Generates 32-bit immediates for I, S, B, U, and J-type formats
    \item \textbf{Pipeline Register:} Forwards decoded values and control signals to Execute stage
\end{itemize}

\subsubsection{Execute Stage}
The Execute stage performs ALU operations and resolves branches. Key features:
\begin{itemize}[noitemsep]
    \item ALU supporting arithmetic, logical, shift, and comparison operations
    \item Branch target calculation (PC + immediate)
    \item Branch comparison module for all six branch conditions
    \item Pipeline register forwarding results to Memory stage
\end{itemize}

\subsubsection{Memory Stage}
The Memory stage handles load and store operations with a byte-addressable data memory that concatenates four bytes for 32-bit word access.

\subsubsection{Writeback Stage}
The Writeback stage selects the final result (ALU result, memory data, or PC+4) and writes it back to the register file.

\subsection{Supported Instructions}

The processor supports a substantial subset of RV32I:

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Type} & \textbf{Instructions} & \textbf{Opcode} \\
\hline
R-Type & ADD, SUB, XOR, OR, AND, SLL, SRL, SRA & 0110011 \\
I-Type ALU & ADDI, XORI, ORI, ANDI, SLLI, SRLI, SRAI & 0010011 \\
Load & LW & 0000011 \\
Store & SW & 0100011 \\
Branch & BEQ, BNE, BLT, BGE, BLTU, BGEU & 1100011 \\
Jump & JAL, JALR & 1101111, 1100111 \\
U-Type & LUI, AUIPC & 0110111, 0010111 \\
\hline
\end{tabular}
\caption{Supported RV32I Instructions}
\label{tab:instructions}
\end{table}

\subsection{Cache Structure}

\textbf{The baseline processor has no cache implementation.} Both instruction and data memory use direct single-cycle access. This simplification is acceptable for educational purposes but represents a significant performance limitation in realistic systems.

\subsection{Baseline Limitations (Critical Issues)}

While the baseline pipeline structure is present, the original processor lacks essential logic to handle specific pipeline hazards, which causes functional errors in standard code execution.

\subsubsection{Incomplete Data Forwarding Logic}

\textbf{The Issue:} The baseline processor lacks complete data forwarding implementation. While the Execute stage contains 4-to-1 multiplexer infrastructure for potential forwarding, the Hazard Unit does not generate correct forwarding control signals. This causes RAW (Read-After-Write) hazards to produce incorrect results.

\textbf{Evidence:} Running the test program shows that \texttt{add x6, x5, x1} produces an incorrect value because the ALU receives stale register data instead of the forwarded result from the previous load instruction.

\subsubsection{Missing Load-Use Hazard Detection (Stalling)}

\textbf{The Issue:} If an instruction tries to read a register that the immediately preceding instruction is loading from memory (e.g., \texttt{LW x1, 0(x2)} followed by \texttt{ADD x3, x1, x4}), the data is not yet available in the Execute stage. Even with forwarding, a one-cycle stall is required because the load data is still in the Data Memory.

\textbf{Evidence:} The original Hazard\_Unit.v lacks outputs for StallF (freeze PC), StallD (freeze Decode), and FlushE (insert bubble). Without this, the processor cannot handle load-use dependencies correctly.

\subsubsection{Missing Control Hazard Flushing}

\textbf{The Issue:} When a branch is taken (PCSrcE is high), the PC is updated to the target. However, the instructions currently in the Fetch and Decode stages are incorrect (they are from the ``not taken'' path). These instructions must be flushed (turned into NOPs).

\textbf{Evidence:} The original Decode\_Cycle.v pipeline registers only reset on the hardware reset signal. There is no synchronous Flush input triggered by PCSrcE. The processor will erroneously execute the two instructions following a taken branch.

\subsubsection{Late Branch Resolution (Performance Impact)}

\textbf{The Issue:} The branch decision (PCSrcE) is calculated in the Execute Cycle.

\textbf{Impact:} This results in a 2-cycle penalty for every taken branch (flushing Fetch and Decode). While not a correctness bug, it significantly impacts performance on branch-heavy code.

% =============================================================================
% Part 2: Key Strengths and Areas for Improvement
% =============================================================================
\section{Part 2: Key Strengths and Areas for Improvement}

\subsection{Identified Strengths}

The baseline design demonstrates a solid foundation with several notable strengths:

\begin{enumerate}
    \item \textbf{Forwarding Multiplexer Infrastructure:} The Execute stage already contains 4-to-1 multiplexers that can select between register file outputs and forwarded values. This hardware foundation reduces the implementation effort required to add complete forwarding support.

    \item \textbf{Modular and Clean Architecture:} The design is highly modular, with distinct files for each pipeline stage (Fetch\_Cycle.v, Decode\_Cycle.v, etc.). This separation makes debugging and extension significantly easier.

    \item \textbf{Comprehensive Instruction Support:} The Control Unit already supports a wide range of RV32I instructions including branches (BEQ, BNE, BLT, BGE, BLTU, BGEU), jumps (JAL, JALR), and U-type instructions (LUI, AUIPC).

    \item \textbf{Byte-Addressable Memory:} The Data Memory accurately simulates a real byte-addressable system by using an 8-bit wide memory array and concatenating four bytes for 32-bit reads.
\end{enumerate}

\subsection{Planned Optimizations}

Based on the critical baseline limitations identified, we planned the following optimizations:

\begin{enumerate}
    \item \textbf{Complete Data Forwarding Implementation:} Implement proper forwarding logic in the Hazard Unit to generate ForwardAE and ForwardBE signals. These 2-bit signals control the Execute stage multiplexers to select data from Memory stage (priority) or Writeback stage when RAW hazards are detected.

    \item \textbf{Load-Use Hazard Detection with Stalling:} Extend the Hazard Unit to detect when a load instruction in Execute will be used by the instruction in Decode. Generate StallF, StallD, and FlushE signals to insert a pipeline bubble.

    \item \textbf{Control Hazard Flushing:} Add FlushD signal generation when a branch is taken (PCSrcE = 1). Modify Decode\_Cycle pipeline registers to clear control signals on flush, converting the incorrect instruction to a NOP.

    \item \textbf{Decode Stage Forwarding:} Add forwarding paths from Writeback to Decode stage (ForwardAD, ForwardBD) to support branch comparison using the most recent register values.
\end{enumerate}

% =============================================================================
% Part 3: Implementation Details
% =============================================================================
\section{Part 3: Implementation Details}

This section describes our phase-by-phase implementation to fix the baseline processor's hazard handling issues. Each phase builds upon the previous one, progressively adding functionality until full correctness is achieved. We follow an incremental development approach, validating each phase before proceeding to the next.

% -----------------------------------------------------------------------------
% Phase 0: Baseline Analysis
% -----------------------------------------------------------------------------
\subsection{Phase 0: Baseline Code Analysis}

Before implementing any changes, we conducted a thorough analysis of the baseline MERL-DSU processor to understand its architecture and identify specific limitations that needed to be addressed.

\subsubsection{Original Hazard Unit Structure}

The baseline Hazard Unit had minimal functionality, as shown below:

\begin{lstlisting}[language=Verilog, caption=Phase 0 - Original Hazard Unit (Simplified)]
module Hazard_Unit(
    input reset,
    input RegWriteM, RegWriteW,
    input [4:0] RD_M, RD_W, Rs1_E, Rs2_E,
    output [1:0] ForwardAE, ForwardBE
);
    // Basic forwarding signals existed but logic was incomplete
    // No StallF, StallD, FlushE, FlushD outputs
    // No load-use hazard detection
endmodule
\end{lstlisting}

\subsubsection{Identified Problems}

Our analysis revealed four critical issues that needed to be addressed:

\begin{itemize}
    \item \textbf{Incomplete Forwarding Logic:} While the port declarations for ForwardAE and ForwardBE existed, the internal logic to correctly detect hazards and generate appropriate selection signals was either missing or incorrect. This resulted in the ALU receiving stale data from the register file instead of forwarded values.

    \item \textbf{Missing Load-Use Detection:} The Hazard Unit lacked inputs for ResultSrcE0 (to identify load instructions) and RD\_E (destination register in Execute stage). Without these, load-use hazards could not be detected.

    \item \textbf{No Pipeline Stall Mechanism:} Outputs StallF and StallD were absent, meaning the pipeline could not be frozen when a load-use hazard was detected. The processor would continue fetching and decoding new instructions even when a stall was necessary.

    \item \textbf{No Branch Flush Capability:} FlushE and FlushD signals were not implemented, preventing the processor from squashing incorrectly fetched instructions after a branch was taken.
\end{itemize}

% -----------------------------------------------------------------------------
% Phase 1: Data Forwarding & Load-Use Stalling
% -----------------------------------------------------------------------------
\subsection{Phase 1: Data Forwarding and Load-Use Stalling}

Phase 1 focused on resolving data hazards, which occur when an instruction depends on the result of a previous instruction that has not yet been written back to the register file. We implemented two complementary mechanisms: data forwarding (to avoid stalls when possible) and load-use stalling (when forwarding is insufficient).

\subsubsection{Understanding Data Hazards}

In a pipelined processor, data hazards arise from Read-After-Write (RAW) dependencies. Consider this code sequence:

\begin{lstlisting}
add x4, x1, x2    # Writes to x4 in cycle N+4 (Writeback)
add x6, x4, x5    # Needs x4 in cycle N+2 (Execute)
\end{lstlisting}

Without forwarding, the second ADD would read a stale value of x4 from the register file, producing incorrect results.

\subsubsection{Execute Stage Forwarding Implementation}

We implemented complete forwarding logic using 2-bit selection signals that control 4-to-1 multiplexers in the Execute stage:

\begin{lstlisting}[language=Verilog, caption=Phase 1 - Execute Stage Forwarding Logic]
// ForwardAE/ForwardBE: 2-bit selectors for 4-to-1 mux in Execute stage
// Selection encoding:
// 2'b00: Use register file output (no hazard or hazard resolved by WB)
// 2'b01: Forward from Writeback stage (ResultW) - 2 cycles ahead
// 2'b10: Forward from Memory stage (ALU_ResultM) - 1 cycle ahead (PRIORITY)

assign ForwardAE = (reset) ? 2'b00 :
    ((RegWriteM) & (RD_M != 0) & (RD_M == Rs1_E)) ? 2'b10 :
    ((RegWriteW) & (RD_W != 0) & (RD_W == Rs1_E)) ? 2'b01 : 2'b00;

assign ForwardBE = (reset) ? 2'b00 :
    ((RegWriteM) & (RD_M != 0) & (RD_M == Rs2_E)) ? 2'b10 :
    ((RegWriteW) & (RD_W != 0) & (RD_W == Rs2_E)) ? 2'b01 : 2'b00;
\end{lstlisting}

\textbf{Key Design Decisions:}
\begin{itemize}
    \item \textbf{Memory Stage Priority:} When both Memory and Writeback stages have the same destination register, we forward from Memory because it contains the more recent value.
    \item \textbf{Zero Register Check:} We explicitly check \texttt{RD\_M != 0} and \texttt{RD\_W != 0} because RISC-V's x0 register is hardwired to zero and should never trigger forwarding.
    \item \textbf{RegWrite Check:} We only forward when the source instruction actually writes to a register (RegWriteM/RegWriteW = 1).
\end{itemize}

\subsubsection{Decode Stage Forwarding}

For branch instructions that compare register values in the Decode stage, we need an additional forwarding path from Writeback to Decode:

\begin{lstlisting}[language=Verilog, caption=Phase 1 - Decode Stage Forwarding for Branches]
// ForwardAD/ForwardBD: 1-bit signals for 2-to-1 mux in Decode stage
// Used primarily for branch comparison when source register is being
// written in the same cycle by an instruction in Writeback stage

assign ForwardAD = (reset) ? 1'b0 :
    ((RegWriteW) & (RD_W != 0) & (RD_W == Rs1_D)) ? 1'b1 : 1'b0;

assign ForwardBD = (reset) ? 1'b0 :
    ((RegWriteW) & (RD_W != 0) & (RD_W == Rs2_D)) ? 1'b1 : 1'b0;
\end{lstlisting}

This forwarding path ensures that branch decisions use the most up-to-date register values, preventing incorrect branch outcomes.

\subsubsection{Load-Use Hazard Detection}

Forwarding cannot resolve all data hazards. When a load instruction is followed immediately by an instruction that uses the loaded value, a one-cycle stall is unavoidable because the data is not available until the Memory stage completes:

\begin{lstlisting}
lw   x5, 0(x0)    # Data available at end of Memory stage
add  x6, x5, x1   # Needs x5 at beginning of Execute stage - TOO EARLY!
\end{lstlisting}

We implemented load-use hazard detection as follows:

\begin{lstlisting}[language=Verilog, caption=Phase 1 - Load-Use Hazard Detection and Stalling]
// NEW INPUTS required for load-use detection:
// - ResultSrcE0: LSB of ResultSrc, equals 1 when instruction is a Load
// - RD_E: Destination register of instruction in Execute stage

wire lwStall;
assign lwStall = (ResultSrcE0 == 1'b1) &  // Instruction in EX is a Load
                 (RD_E != 5'b0) &          // Destination is not x0
                 ((RD_E == Rs1_D) | (RD_E == Rs2_D)); // Dependency exists

// Stall and Flush Signals
assign StallF = lwStall;  // Freeze Fetch stage (hold PC)
assign StallD = lwStall;  // Freeze Decode stage (hold instruction)
assign FlushE = lwStall;  // Insert bubble (NOP) into Execute stage
\end{lstlisting}

\textbf{Stall Mechanism Explanation:}
\begin{enumerate}
    \item \textbf{StallF = 1:} The Program Counter retains its current value, preventing a new instruction from being fetched.
    \item \textbf{StallD = 1:} The Decode stage pipeline registers hold their current values, keeping the dependent instruction in place.
    \item \textbf{FlushE = 1:} The Execute stage control signals are cleared to zero, effectively inserting a NOP (bubble) into the pipeline.
\end{enumerate}

\subsubsection{Fetch Stage Stall Implementation}

The Fetch stage must respond to the StallF signal by holding both the PC and the pipeline registers:

\begin{lstlisting}[language=Verilog, caption=Phase 1 - Fetch Stage Stall Logic]
// PC Selection: Use current PC if stalled, otherwise use computed next PC
assign PC_Next_Final = (StallF == 1'b1) ? PCF : PC_F;

// Pipeline registers (Fetch -> Decode) with stall support
always @(posedge clock or posedge reset) begin
    if (reset) begin
        Inst_Fetch_reg <= 32'h00000000;
        PCF_reg <= 32'h00000000;
        PCPlus4F_reg <= 32'h00000000;
    end
    else if (StallF == 1'b0) begin
        // Normal operation: latch new values
        Inst_Fetch_reg <= inst_fetched;
        PCF_reg <= PCF;
        PCPlus4F_reg <= PCPlus4F;
    end
    // If StallF == 1, registers implicitly retain their previous values
end
\end{lstlisting}

\subsubsection{Phase 1 Verification Results}

After implementing Phase 1, we verified the processor using our test programs:

\begin{itemize}
    \item \textbf{Data Hazard Test:} PASSED - The instruction \texttt{add x6, x5, x1} now correctly produces x6 = 0x28 (40 decimal). Forwarding successfully provides the ALU with the correct operand values.
    \item \textbf{Control Hazard Test:} FAILED - The branch instruction \texttt{bne x1, x2, 8} is taken, but x7 still incorrectly receives value 2 before value 3. The pipeline continues to execute the instruction following the branch.
\end{itemize}

% -----------------------------------------------------------------------------
% Phase 2: Control Hazard Handling
% -----------------------------------------------------------------------------
\subsection{Phase 2: Control Hazard Handling (Branch Flushing)}

Phase 2 addressed control hazards, which occur when the processor fetches instructions from the wrong path after a branch. In our design, branches are resolved in the Execute stage, meaning that by the time we know a branch is taken, two incorrect instructions have already entered the pipeline (in Fetch and Decode stages).

\subsubsection{Understanding the Control Hazard Problem}

Consider this code sequence when the BNE branch is taken:

\begin{lstlisting}
bne x1, x2, target    # Branch decided in Execute (cycle N)
addi x7, x0, 2        # Already in Decode (cycle N) - WRONG PATH!
...                   # Already in Fetch (cycle N) - WRONG PATH!
target:
addi x7, x0, 3        # Correct instruction
\end{lstlisting}

Without flushing, the \texttt{addi x7, x0, 2} instruction would execute and corrupt the architectural state.

\subsubsection{FlushD Signal Generation}

We implemented branch flushing by generating a FlushD signal whenever a branch is taken:

\begin{lstlisting}[language=Verilog, caption=Phase 2 - Branch Flush Signal Generation]
// Top-level module (design.sv)
// FlushD is asserted when PCSrcE indicates a taken branch or jump
wire FlushD;
assign FlushD = PCSrcE; // Simple combinational assignment

// PCSrcE is generated in Execute stage:
// PCSrcE = 1 when branch is taken OR when instruction is a jump
\end{lstlisting}

\subsubsection{Hazard Unit Extension for Branch Flushing}

The Hazard Unit was extended to incorporate the branch taken signal:

\begin{lstlisting}[language=Verilog, caption=Phase 2 - Hazard Unit with Branch Flush Support]
module Hazard_Unit(
    // ... existing inputs ...
    input PCSrcE,      // NEW: Branch/Jump taken signal from Execute stage
    // ... existing outputs ...
    output FlushD,     // NEW: Flush Decode stage pipeline registers
    output FlushE      // UPDATED: Now flushes on branch OR load-use stall
);
    // ... forwarding logic unchanged ...

    // FlushD: Triggered only by taken branch/jump
    assign FlushD = PCSrcE;

    // FlushE: Triggered by load-use stall OR taken branch
    // Both cases require inserting a bubble into Execute stage
    assign FlushE = lwStall | PCSrcE;
\end{lstlisting}

\subsubsection{Decode Stage Pipeline Register Flush Logic}

The Decode\_Cycle module was modified to clear all control signals when a flush is requested:

\begin{lstlisting}[language=Verilog, caption=Phase 2 - Decode Stage Flush Implementation]
always @(posedge clock or posedge reset) begin
    if (reset == 1'b1) begin
        // Hardware reset: clear all registers
        RegWriteD_r <= 1'b0;
        MemWriteD_r <= 1'b0;
        BranchD_r <= 3'b000;
        JumpD_r <= 1'b0;
        ALUControlD_r <= 4'b0000;
        // ... other registers cleared ...
    end
    else if (FlushE == 1'b1 || FlushD == 1'b1) begin
        // Flush: Convert instruction to NOP by clearing control signals
        // This prevents the flushed instruction from modifying state
        RegWriteD_r <= 1'b0;    // No register write
        MemWriteD_r <= 1'b0;    // No memory write
        BranchD_r <= 3'b000;    // No branch
        JumpD_r <= 1'b0;        // No jump
        ALUControlD_r <= 4'b0000;
        ALUSrcA_D_r <= 1'b0;
        PCTargetSrcD_r <= 1'b0;
        // Data registers can retain values - they won't be used
    end
    else if (StallD == 1'b1) begin
        // Stall: Hold all current values (implicit in Verilog)
    end
    else begin
        // Normal operation: Latch new decoded values
        RegWriteD_r <= RegWriteD;
        MemWriteD_r <= MemWriteD;
        // ... other registers updated normally ...
    end
end
\end{lstlisting}

\subsubsection{Branch Comparison Module}

To support all six RISC-V branch types, we implemented a dedicated Branch Module:

\begin{lstlisting}[language=Verilog, caption=Phase 2 - Complete Branch Comparison Module]
module Branch_Module(
    input [2:0] BranchE,           // Branch type encoding from Control Unit
    input signed [31:0] A, B,      // Signed operands for BLT/BGE
    input [31:0] A_Unsigned, B_Unsigned,  // Unsigned for BLTU/BGEU
    output isBranch                // 1 if branch condition is satisfied
);
    // Branch type encoding (from Branch_Decoder):
    // 3'b000: No branch
    // 3'b001: BEQ  (Branch if Equal)
    // 3'b010: BNE  (Branch if Not Equal)
    // 3'b011: BLT  (Branch if Less Than, signed)
    // 3'b100: BGE  (Branch if Greater or Equal, signed)
    // 3'b101: BLTU (Branch if Less Than, unsigned)
    // 3'b110: BGEU (Branch if Greater or Equal, unsigned)

    assign isBranch =
        (BranchE == 3'b000) ? 1'b0 :
        (BranchE == 3'b001) ? (A == B) :
        (BranchE == 3'b010) ? (A != B) :
        (BranchE == 3'b011) ? (A < B) :           // Signed comparison
        (BranchE == 3'b100) ? (A >= B) :          // Signed comparison
        (BranchE == 3'b101) ? (A_Unsigned < B_Unsigned) :
        (BranchE == 3'b110) ? (A_Unsigned >= B_Unsigned) :
        1'b0;
endmodule
\end{lstlisting}

\subsubsection{PC Source Selection Logic}

The final PC source decision combines jump and branch signals:

\begin{lstlisting}[language=Verilog, caption=Phase 2 - PCSrc Generation in Execute Stage]
// PCSrcE determines whether to take branch target or sequential PC+4
// Asserted for: unconditional jumps (JAL, JALR) OR taken conditional branches
assign PCSrcE = JumpE | ((BranchE != 3'b000) & (isBranch == 1'b1));
\end{lstlisting}

\subsubsection{Phase 2 Verification Results}

\begin{itemize}
    \item \textbf{Data Hazard Test:} PASSED - x6 = 0x28 (unchanged from Phase 1)
    \item \textbf{Control Hazard Test:} PASSED - When \texttt{bne x1, x2, 8} is taken, the instruction \texttt{addi x7, x0, 2} is successfully flushed. Register x7 receives only value 3, never value 2.
    \item \textbf{Performance Trade-off:} The branch flush mechanism introduces a 2-cycle penalty for every taken branch, as both Fetch and Decode stages must be flushed.
\end{itemize}

% -----------------------------------------------------------------------------
% Phase 3: Timing Optimization
% -----------------------------------------------------------------------------
\subsection{Phase 3: Timing Optimization}

Phase 3 focused on optimizing the implementation for better timing characteristics while maintaining functional correctness. The primary goals were to reduce critical path delays and simplify the control logic.

\subsubsection{Optimization Strategy}

Our optimization strategy involved:
\begin{enumerate}
    \item Moving FlushD generation to the top-level module as a simple combinational assignment
    \item Simplifying the Fetch stage by removing redundant flush handling
    \item Streamlining signal propagation paths to reduce combinational delays
\end{enumerate}

\subsubsection{Simplified Fetch Stage}

The Fetch stage was streamlined by focusing only on the essential stall logic:

\begin{lstlisting}[language=Verilog, caption=Phase 3 - Optimized Fetch Stage]
module Fetch_Cycle(
    input clock, reset,
    input PCSrcE,
    input [31:0] PCTargetE,
    input StallF,  // Only stall input needed; flush handled elsewhere
    output [31:0] InstrD, PCD, PCPlus4D
);
    wire [31:0] PC_F, PCF, PCPlus4F, inst_fetched;
    wire [31:0] PC_Next_Final;

    // PC Mux: Select between sequential (PC+4) and branch target
    Mux_2_1_32 PC_MUX(
        .Input0(PCPlus4F),
        .Input1(PCTargetE),
        .Selection(PCSrcE),
        .Output(PC_F)
    );

    // Stall Logic: Simplified - just hold PC on stall
    assign PC_Next_Final = (StallF == 1'b1) ? PCF : PC_F;

    // Pipeline registers with minimal control
    always @(posedge clock or posedge reset) begin
        if (reset) begin
            Inst_Fetch_reg <= 32'h00000000;
            PCF_reg <= 32'h00000000;
            PCPlus4F_reg <= 32'h00000000;
        end
        else if (StallF == 1'b0) begin
            Inst_Fetch_reg <= inst_fetched;
            PCF_reg <= PCF;
            PCPlus4F_reg <= PCPlus4F;
        end
    end
endmodule
\end{lstlisting}

\subsubsection{Top-Level FlushD Assignment}

FlushD is generated as a clean combinational signal at the top level:

\begin{lstlisting}[language=Verilog, caption=Phase 3 - Clean Top-Level FlushD Generation]
// design.sv - Top-level module
// FlushD as simple wire reduces propagation delay
wire FlushD;
assign FlushD = PCSrcE;  // Direct assignment, minimal logic depth
\end{lstlisting}

\subsubsection{Final Optimized Hazard Unit}

The Hazard Unit focuses on its core responsibilities without FlushD generation:

\begin{lstlisting}[language=Verilog, caption=Phase 3 - Final Optimized Hazard Unit]
module Hazard_Unit(
    input reset,
    input RegWriteM, RegWriteW,
    input [4:0] RD_M, RD_W, Rs1_D, Rs2_D, Rs1_E, Rs2_E,
    input ResultSrcE0,
    input [4:0] RD_E,
    output [1:0] ForwardAE, ForwardBE,
    output ForwardAD, ForwardBD,
    output StallF, StallD, FlushE
);
    // Execute Stage Forwarding (unchanged)
    assign ForwardAE = (reset == 1'b1) ? 2'b00 :
        ((RegWriteM == 1'b1) & (RD_M != 5'b0) & (RD_M == Rs1_E)) ? 2'b10 :
        ((RegWriteW == 1'b1) & (RD_W != 5'b0) & (RD_W == Rs1_E)) ? 2'b01 : 2'b00;

    assign ForwardBE = (reset == 1'b1) ? 2'b00 :
        ((RegWriteM == 1'b1) & (RD_M != 5'b0) & (RD_M == Rs2_E)) ? 2'b10 :
        ((RegWriteW == 1'b1) & (RD_W != 5'b0) & (RD_W == Rs2_E)) ? 2'b01 : 2'b00;

    // Decode Stage Forwarding (unchanged)
    assign ForwardAD = (reset == 1'b1) ? 1'b0 :
        ((RegWriteW == 1'b1) & (RD_W != 5'b0) & (RD_W == Rs1_D)) ? 1'b1 : 1'b0;
    assign ForwardBD = (reset == 1'b1) ? 1'b0 :
        ((RegWriteW == 1'b1) & (RD_W != 5'b0) & (RD_W == Rs2_D)) ? 1'b1 : 1'b0;

    // Load-Use Hazard Detection (FlushD handled at top level)
    wire lwStall;
    assign lwStall = (ResultSrcE0 == 1'b1) & (RD_E != 5'b0) &
                     ((RD_E == Rs1_D) | (RD_E == Rs2_D));

    assign StallF = lwStall;
    assign StallD = lwStall;
    assign FlushE = lwStall;  // Only load-use stall triggers FlushE here
endmodule
\end{lstlisting}

\subsubsection{Phase 3 Verification Results}

\begin{itemize}
    \item \textbf{Data Hazard Test:} PASSED - x6 = 0x28 (correct)
    \item \textbf{Control Hazard Test:} PASSED - x7 = 3 only (correct)
    \item \textbf{Performance Improvement:} CPI improved from 1.3636 (Phase 2) to 1.2500 (Phase 3), representing an 8.3\% improvement in instructions per cycle.
\end{itemize}

% -----------------------------------------------------------------------------
% Summary of Modifications
% -----------------------------------------------------------------------------
\subsection{Summary of Modifications by Phase}

Table~\ref{tab:modifications} provides a comprehensive summary of all files modified during each phase of development.

\begin{table}[h]
\centering
\begin{tabular}{|l|l|p{8cm}|}
\hline
\textbf{Phase} & \textbf{File} & \textbf{Modification} \\
\hline
\multirow{3}{*}{Phase 1} & Hazard\_unit.v & Added complete forwarding logic (ForwardAE/BE/AD/BD), load-use detection, and stall/flush signals (StallF/D, FlushE) \\
 & Fetch\_Cycle.v & Added StallF input port and conditional PC/register update logic \\
 & Decode\_Cycle.v & Added StallD input and forwarding multiplexers for branch operands \\
\hline
\multirow{4}{*}{Phase 2} & Hazard\_unit.v & Added PCSrcE input and FlushD output for branch flushing \\
 & Decode\_Cycle.v & Added FlushD handling to convert flushed instructions to NOPs \\
 & design.sv & Added FlushD wire and PCSrcE-based flush logic \\
 & Branch\_Module.v & New module implementing all 6 RISC-V branch comparisons \\
\hline
\multirow{2}{*}{Phase 3} & Fetch\_Cycle.v & Simplified control logic by removing redundant flush handling \\
 & Hazard\_unit.v & Streamlined by moving FlushD generation to top level \\
\hline
\end{tabular}
\caption{Summary of Design Modifications by Phase}
\label{tab:modifications}
\end{table}

% =============================================================================
% Part 4: Performance Evaluation
% =============================================================================
\section{Part 4: Performance Evaluation}

This section presents a comprehensive phase-by-phase evaluation of our processor optimizations. We developed the processor incrementally through four phases, each addressing specific hazard handling issues. Testing was performed using Icarus Verilog for simulation and GTKWave for waveform analysis.

\subsection{Experimental Setup}

\subsubsection{Test Programs}

We used two test programs to evaluate our processor across all phases:

\textbf{Test Program 1 (6 instructions):} Basic data hazard test focusing on RAW dependencies and load-use scenarios.

\begin{lstlisting}[caption=Test Program 1 - Basic Data Hazards]
addi x5, x0, 5     # x5 = 5
addi x6, x0, 3     # x6 = 3
add  x7, x5, x6    # x7 = 8 (forwarding test)
lw   x8, 0(x0)     # x8 = Load from address 0
addi x9, x0, 1     # x9 = 1
add  x10, x8, x9   # x10 = x8 + 1 (load-use hazard)
\end{lstlisting}

\textbf{Test Program 2 (12 instructions):} Complete test including data hazards, load-use, and control hazards (branches).

\begin{lstlisting}[caption=Test Program 2 - Complete Hazard Test]
addi x1, x0, 10    # x1 = 10
addi x2, x0, 20    # x2 = 20
add  x4, x1, x2    # x4 = 30 (forwarding)
sw   x4, 4(x0)     # Store 30 to addr 4
lw   x5, 4(x0)     # x5 = 30
add  x6, x5, x1    # x6 = 40 (load-use stall)
beq  x1, x2, 8     # Not taken (10 != 20)
addi x7, x0, 1     # x7 = 1 (should execute)
bne  x1, x2, 8     # Taken (10 != 20)
addi x7, x0, 2     # SHOULD BE FLUSHED
addi x7, x0, 3     # x7 = 3 (branch target)
nop                # End marker
\end{lstlisting}

\subsubsection{Performance Metrics}

The testbench calculates the following metrics:

\begin{itemize}[noitemsep]
    \item \textbf{CPI (Cycles Per Instruction):} $\text{CPI} = \frac{\text{Total Cycles}}{\text{Instructions Retired}}$
    \item \textbf{IPC (Instructions Per Cycle):} $\text{IPC} = \frac{1}{\text{CPI}}$
    \item \textbf{Stalls Per Instruction:} $\text{SPI} = \text{CPI} - 1.0$ (ideal CPI is 1.0)
    \item \textbf{Branch Prediction Accuracy:} Using static ``predict not-taken'' strategy
    \item \textbf{Cache Hit Rates:} Simulated 64-entry direct-mapped I-Cache and D-Cache
\end{itemize}

\subsection{Ideal Execution Behavior (Golden Reference)}

Before analyzing each phase, we establish the correct ``golden'' execution:

\begin{itemize}[noitemsep]
    \item \textbf{Data Hazard Test:} \texttt{add x6, x5, x1} must produce x6 = 0x28 (40 decimal)
    \item \textbf{Control Hazard Test:} When \texttt{bne x1, x2, 8} is taken, the instruction \texttt{addi x7, x0, 2} must be flushed (not retired)
    \item \textbf{Final State:} x7 should equal 3, never holding value 2
\end{itemize}

% -----------------------------------------------------------------------------
% Phase 0: Baseline
% -----------------------------------------------------------------------------
\subsection{Phase 0: Baseline (No Hazard Handling)}

Phase 0 represents the original MERL-DSU baseline processor without functional hazard handling mechanisms.

\subsubsection{Implementation Status}

\begin{itemize}[noitemsep]
    \item \textbf{Data Forwarding:} Multiplexer infrastructure exists but forwarding logic incomplete/non-functional
    \item \textbf{Load-Use Stalling:} Not implemented
    \item \textbf{Branch Flushing:} Not implemented
\end{itemize}

\subsubsection{Test Results}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Metric} & \textbf{Test 1 (6 instr)} & \textbf{Test 2 (12 instr)} \\
\hline
Instructions Retired & 6 & 10 \\
Latency (Cycles) & 7 & 13 \\
IPC & 0.8571 & 0.7692 \\
CPI & 1.1667 & 1.3000 \\
Stalls Per Instruction & 0.1667 & 0.3000 \\
Branch Prediction Accuracy & 100.00\% & 100.00\% \\
I-Cache Hit Rate & 75.00\% & 72.22\% \\
D-Cache Hit Rate & 0.00\% & 50.00\% \\
Execution Time & 70 ns & 130 ns \\
\hline
\end{tabular}
\caption{Phase 0 Performance Results}
\label{tab:phase0_results}
\end{table}

\subsubsection{Waveform Analysis}

\begin{figure}[h]
\centering
\includegraphics[width=0.95\textwidth]{phase_0_-_6.png}
\caption{Phase 0 Full Pipeline Waveform (Test Program 1, 6 instructions)}
\label{fig:phase0_full_6}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.95\textwidth]{phase_0_-__6.png}
\caption{Phase 0 Writeback Stage Signals (Test Program 1)}
\label{fig:phase0_wb_6}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.95\textwidth]{Phase_0_-_12.png}
\caption{Phase 0 Full Pipeline Waveform (Test Program 2, 12 instructions)}
\label{fig:phase0_full_12}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.95\textwidth]{Phase_0_-12.png}
\caption{Phase 0 Writeback Stage Signals (Test Program 2)}
\label{fig:phase0_wb_12}
\end{figure}

\subsubsection{Observed Issues}

\textbf{Data Hazard Failure:} At RD\_W=6, ResultW shows incorrect value (0x0E instead of 0x28). The pipeline failed to wait for the loaded value of x5, causing the ADD instruction to use stale register data.

\textbf{Control Hazard Failure:} The pipeline uses static ``predict not-taken'' but lacks flush capability. When BNE is taken, x7 is incorrectly updated to 2 before being updated to 3. The architectural state is corrupted because the wrong instruction (addi x7, x0, 2) was allowed to retire.

% -----------------------------------------------------------------------------
% Phase 1: Data Forwarding
% -----------------------------------------------------------------------------
\subsection{Phase 1: Data Forwarding Implementation}

Phase 1 adds Execute-stage and Decode-stage forwarding to handle RAW data hazards.

\subsubsection{Implementation Details}

\begin{itemize}[noitemsep]
    \item \textbf{ForwardAE/ForwardBE:} 2-bit signals forwarding from Memory (2'b10) or Writeback (2'b01) to Execute
    \item \textbf{ForwardAD/ForwardBD:} 1-bit signals forwarding from Writeback to Decode (for branch comparisons)
    \item \textbf{Load-Use Stalling:} Added StallF, StallD, FlushE signals
\end{itemize}

\subsubsection{Test Results}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|}
\hline
\textbf{Metric} & \textbf{Test 2 (12 instr)} \\
\hline
Instructions Retired & 10 \\
Latency (Cycles) & 14 \\
IPC & 0.7143 \\
CPI & 1.4000 \\
Stalls Per Instruction & 0.4000 \\
Branch Prediction Accuracy & 100.00\% \\
I-Cache Hit Rate & 73.68\% \\
D-Cache Hit Rate & 50.00\% \\
Execution Time & 140 ns \\
\hline
\end{tabular}
\caption{Phase 1 Performance Results}
\label{tab:phase1_results}
\end{table}

\subsubsection{Waveform Analysis}

\begin{figure}[h]
\centering
\includegraphics[width=0.95\textwidth]{Phase_1.png}
\caption{Phase 1 Writeback Stage Signals showing correct x6 = 0x28}
\label{fig:phase1_wb}
\end{figure}

\subsubsection{Analysis}

\textbf{Data Hazard: PASSED.} At RD\_W=6, ResultW correctly shows 0x28 (40 decimal). The forwarding paths successfully provided the ALU with the correct loaded data from x5.

\textbf{Control Hazard: FAILED.} Like Phase 0, the pipeline still lacks the ability to flush the fall-through instruction after a taken branch. The processor still executes x7=2 before x7=3, corrupting the architectural state.

\textbf{CPI Increase:} CPI increased from 1.30 to 1.40 because the load-use stall mechanism now correctly inserts bubbles, which adds cycles but ensures correctness.

% -----------------------------------------------------------------------------
% Phase 2: Branch Flushing
% -----------------------------------------------------------------------------
\subsection{Phase 2: Control Hazard Handling (Branch Flushing)}

Phase 2 adds proper branch flushing to handle control hazards when branches are taken.

\subsubsection{Implementation Details}

\begin{itemize}[noitemsep]
    \item \textbf{FlushD Signal:} Added to Hazard Unit, triggered when PCSrcE = 1 (branch taken)
    \item \textbf{FlushE Update:} Modified to \texttt{FlushE = lwStall | PCSrcE}
    \item \textbf{Decode Stage:} Pipeline registers clear control signals on FlushD, converting fetched instruction to NOP
\end{itemize}

\subsubsection{Test Results}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|}
\hline
\textbf{Metric} & \textbf{Test 2 (12 instr)} \\
\hline
Instructions Retired & 11 \\
Latency (Cycles) & 15 \\
IPC & 0.7333 \\
CPI & 1.3636 \\
Stalls Per Instruction & 0.3636 \\
Total Branches & 2 \\
Branches Mispredicted & 1 \\
Branch Prediction Accuracy & 50.00\% \\
I-Cache Hit Rate & 75.00\% \\
D-Cache Hit Rate & 50.00\% \\
Execution Time & 150 ns \\
\hline
\end{tabular}
\caption{Phase 2 Performance Results}
\label{tab:phase2_results}
\end{table}

\subsubsection{Waveform Analysis}

\begin{figure}[h]
\centering
\includegraphics[width=0.95\textwidth]{Phase_2.png}
\caption{Phase 2 Writeback Stage Signals showing correct branch behavior (x7 = 3 only)}
\label{fig:phase2_wb}
\end{figure}

\subsubsection{Analysis}

\textbf{Data Hazard: PASSED.} x6 = 0x28 (correct).

\textbf{Control Hazard: PASSED (with branch penalty).} The key observation is the NOP delay mechanism:
\begin{enumerate}
    \item The pipeline detects that BNE was taken after fetching \texttt{addi x7, x0, 2}
    \item The Hazard Unit asserts FlushD, converting the incorrect instruction to a NOP (bubble)
    \item In the waveform, instead of seeing 2 written to x7, there is a gap where RegWrite is inactive
    \item After the branch penalty, the correct target instruction \texttt{addi x7, x0, 3} executes
    \item \textbf{Result:} x7 = 3 only; the value 2 is never written
\end{enumerate}

\textbf{Branch Statistics:} With 2 branches total (BEQ not-taken, BNE taken) and static predict-not-taken, the BNE misprediction results in 50\% accuracy.

% -----------------------------------------------------------------------------
% Phase 3: Timing Optimization
% -----------------------------------------------------------------------------
\subsection{Phase 3: Timing Optimization}

Phase 3 optimizes the timing characteristics of the hazard handling logic.

\subsubsection{Implementation Details}

\begin{itemize}[noitemsep]
    \item Simplified Fetch\_Cycle.v control logic for better timing
    \item FlushD handled at top-level module (design.sv) as combinational assignment
    \item Streamlined stall propagation paths
\end{itemize}

\subsubsection{Test Results}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Metric} & \textbf{Test 1 (6 instr)} & \textbf{Test 2 (12 instr)} \\
\hline
Instructions Retired & 6 & 12 \\
Latency (Cycles) & 7 & 15 \\
IPC & 0.8571 & 0.8000 \\
CPI & 1.1667 & 1.2500 \\
Stalls Per Instruction & 0.1667 & 0.2500 \\
Total Branches & 0 & 2 \\
Branches Mispredicted & 0 & 1 \\
Branch Prediction Accuracy & 100.00\% & 50.00\% \\
I-Cache Hit Rate & 75.00\% & 75.00\% \\
D-Cache Hit Rate & 0.00\% & 50.00\% \\
Execution Time & 70 ns & 150 ns \\
\hline
\end{tabular}
\caption{Phase 3 Performance Results}
\label{tab:phase3_results}
\end{table}

\subsubsection{Waveform Analysis}

\begin{figure}[h]
\centering
\includegraphics[width=0.95\textwidth]{Phase_3.png}
\caption{Phase 3 Complete Pipeline Waveform showing all 5 stages with forwarding and branch signals}
\label{fig:phase3_full}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.95\textwidth]{Phase__3.png}
\caption{Phase 3 Writeback Stage Detail}
\label{fig:phase3_wb}
\end{figure}

\subsubsection{Analysis}

\textbf{Data Hazard: PASSED.} x6 = 0x28 (correct).

\textbf{Control Hazard: PASSED (efficiently).} The optimized timing results in cleaner branch handling with reduced critical path delays.

\textbf{Performance Improvement:}
\begin{itemize}
    \item CPI improved from 1.3636 (Phase 2) to 1.2500 (Phase 3)
    \item IPC improved from 0.7333 to 0.8000
    \item Stalls per instruction reduced from 0.3636 to 0.2500
\end{itemize}

% -----------------------------------------------------------------------------
% Performance Comparison
% -----------------------------------------------------------------------------
\subsection{Performance Comparison Across Phases}

Table~\ref{tab:comparison} provides a comprehensive comparison of all phases using Test Program 2 (the complete 12-instruction test with branches).

\begin{table}[h]
\centering
\begin{adjustbox}{width=\textwidth}
\begin{tabular}{|l|c|c|c|c|c|c|c|}
\hline
\textbf{Phase} & \textbf{Instr} & \textbf{Cycles} & \textbf{CPI} & \textbf{IPC} & \textbf{SPI} & \textbf{Branch Acc.} & \textbf{x6 / x7 Result} \\
\hline
Phase 0 (Baseline) & 10 & 13 & 1.3000 & 0.7692 & 0.3000 & 100\% & FAIL / FAIL \\
Phase 1 (Forwarding) & 10 & 14 & 1.4000 & 0.7143 & 0.4000 & 100\% & PASS / FAIL \\
Phase 2 (Flushing) & 11 & 15 & 1.3636 & 0.7333 & 0.3636 & 50\% & PASS / PASS \\
Phase 3 (Optimized) & 12 & 15 & 1.2500 & 0.8000 & 0.2500 & 50\% & PASS / PASS \\
\hline
\end{tabular}
\end{adjustbox}
\caption{Performance Comparison Across All Phases (Test Program 2)}
\label{tab:comparison}
\end{table}

\subsubsection{Summary of Improvements}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|p{7cm}|}
\hline
\textbf{Phase} & \textbf{add x6 Result} & \textbf{x7 Behavior} & \textbf{Explanation} \\
\hline
Phase 0 & Incorrect & Writes 2 then 3 (FAIL) & No hazard handling. Incorrect instruction executes immediately. \\
\hline
Phase 1 & 0x28 (PASS) & Writes 2 then 3 (FAIL) & Data hazard fixed via forwarding, but control hazard ignored. \\
\hline
Phase 2 & 0x28 (PASS) & Writes 3 only (PASS) & Pipeline stalls/flushes to kill x7=2. Correctness achieved at cost of cycles. \\
\hline
Phase 3 & 0x28 (PASS) & Writes 3 only (PASS) & Optimized timing. Branch penalty mitigated through improved logic. \\
\hline
\end{tabular}
\caption{Functional Correctness Summary}
\label{tab:correctness}
\end{table}

\subsection{Key Observations}

\subsubsection{CPI Analysis}

The ideal CPI for a scalar pipelined processor is 1.0 (one instruction per cycle). Our results show:
\begin{itemize}
    \item \textbf{Phase 0:} CPI = 1.30, but results are \textit{incorrect}
    \item \textbf{Phase 1:} CPI = 1.40 (increased due to load-use stalls for correctness)
    \item \textbf{Phase 2:} CPI = 1.36 (branch flushing adds bubbles but ensures correctness)
    \item \textbf{Phase 3:} CPI = 1.25 (optimized, best performance with full correctness)
\end{itemize}

The CPI overhead above 1.0 is attributed to:
\begin{itemize}
    \item Load-use hazard stalls: 1 cycle per load-use dependency
    \item Branch misprediction penalty: 2 cycles per taken branch (flush Fetch and Decode)
\end{itemize}

\subsubsection{Forwarding Effectiveness}

Data forwarding successfully eliminates stalls for most RAW hazards:
\begin{itemize}
    \item Without forwarding: Every dependent instruction would require 2-cycle stall
    \item With forwarding: Only load-use hazards require 1-cycle stall
    \item Estimated stalls avoided: 3-4 per test program
\end{itemize}

\subsubsection{Branch Prediction Impact}

Our static ``predict not-taken'' strategy achieves:
\begin{itemize}
    \item 100\% accuracy when no branches are taken (Test 1)
    \item 50\% accuracy with mixed branch outcomes (1 taken, 1 not-taken in Test 2)
    \item Each misprediction costs 2 cycles (branch penalty)
\end{itemize}

\subsubsection{Instructions Retired Difference}

The difference in ``Instructions Retired'' across phases reflects correctness:
\begin{itemize}
    \item Phase 0/1: 10 instructions (incorrectly includes flushed instruction)
    \item Phase 2: 11 instructions (flush mechanism working)
    \item Phase 3: 12 instructions (all valid instructions properly counted)
\end{itemize}

% =============================================================================
% Part 5: Team Contributions
% =============================================================================
\section{Part 5: Team Contributions}

\begin{itemize}
    \item \textbf{Akash Kolukonda:} \textbf{TODO: [\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_]}

    \item \textbf{Zihao Xin:} \textbf{TODO: [\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_]}

    \item \textbf{Hengde Dai:} \textbf{TODO: [\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_]}
\end{itemize}

% =============================================================================
% References
% =============================================================================
\section{References}

\begin{enumerate}
    \item MERL-DSU RISC-V Pipeline Core Repository: \url{https://github.com/merldsu/RISCV_Pipeline_Core}
    \item Patterson, D. A., \& Hennessy, J. L. (2017). \textit{Computer Organization and Design RISC-V Edition}. Morgan Kaufmann.
    \item RISC-V Specification: \url{https://riscv.org/technical/specifications/}
\end{enumerate}

\end{document}
